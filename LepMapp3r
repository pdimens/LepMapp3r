#! /usr/bin/env bash
## This bash wrapper is will act like a liason to run LepMap3's various modules. Strongly recommended to run this in a screen environment. 

parentcall(){
    printf "->"
    printf "\033[01;33m"
    printf "\nParentCall"
    printf "\033[0m"
    echo -e "\n------------List of all files in directory------------"
    ls .
    echo -e "------------------------------------------------------"
    printf '\nWhat is the name of the pedigree file?  '
    read -r PEDIGREE
    if [ ! -f $PEDIGREE ]; then
        echo "Error: $PEDIGREE not found in working directory. Please check spelling." && exit 1
    fi
    printf 'What is the name of the filtered vcf file?  '
    read -r VCFFILE
    if [ ! -f $VCFFILE ]; then
        echo "Error: $VCFFILE not found in working directory. Please check spelling." && exit 1
    fi
    java $LM3PATH ParentCall2 data=${PEDIGREE} vcfFile=${VCFFILE} removeNonInformative=1 | gzip >data.call.gz

    echo -e "\n-- Initiating Filtering2 module --"
    printf '\nSpecify your data tolerance (0.0001 to 0.01):  '
    read -r DTOLERANCE
    zcat data.call.gz | java $LM3PATH Filtering2 data=- dataTolerance=$DTOLERANCE | gzip >data_f.call.gz
}

export -f parentcall

separatechromosomes(){
    printf "\nParentCall->"
    printf "\033[01;33m" 
    printf " SeparateChromosomes\n" 
    printf "\033[0m"
    echo -e "\nChromosome separation can be iterated over a range of LOD score limits to find the best map"
    printf 'What LOD limit do you want to start with?  '
    read -r LODSTART
    printf 'What LOD limit do you want to end with?  '
    read -r LODEND 
    echo -e "\nThis may take a while depending on your data and the range of LOD score you want to explore."
    printf 'How many CPUs would you like to use per iteration (max=%s)?  ' "$(nproc)"
    read -r NBPROCS
    mkdir -p iter.maps
    for i in $(seq $LODSTART $LODEND)
        do
        zcat data_f.call.gz | java $LM3PATH SeparateChromosomes2 data=- lodLimit=$i distortionLod=1 numThreads=$NBPROCS > iter.maps/map.LOD.$i.txt
        sort iter.maps/map.LOD.$i.txt | uniq -c | sort -n > iter.maps/map.$i.summary.txt
    done
    echo -e "\nExamine the maps produced ("iter.maps/map.LOD.X.txt") and decide on the best map before proceeding"
    echo "if using a screen environment, press ctrl+a then d to detach the screen and when ready return to it with the command "screen -r" "
    echo "if not using a screen, press ctrl+z to pause followed by the "bg" command to put in the background. When ready, enter the "fg" command to bring LepMapp3r into the foreground again"
    echo "Press Enter to proceed"
    read PROCEED
}

export -f separatechromosomes

joinsingles(){
    printf  "\n ParentCall->SeparateChromosomes->"
    printf "\033[01;33m" 
    printf " JoinSingles\n" 
    printf "\033[0m"
    echo -e "\n------------List of map files in iter.maps/------------"
    find ./iter.maps -name "map.LOD.*.txt"  -printf "%f\t"
    echo -e "\n------------------------------------------------------\n"
    printf 'Which map would you like to use (just the filename, exclude directory)?  '
    read -r BESTMAP
    if [ ! -f iter.maps/$BESTMAP ]; then
        echo "Error: iter.maps/$BESTMAP not found in working directory. Please check spelling." && exit 1
    fi
    printf 'LOD limit (4 is common)?  '
    read -r LODLIMIT
    printf 'LOD difference cutoff (2 is common)?  '
    read -r LODDIFF
    printf 'How many CPUs would you like to use per iteration (max=%s)?  ' "$(nproc)"
    read -r PROCS
    DATAMAP=$(echo "MASTER.$BESTMAP")
    zcat data_f.call.gz | java $LM3PATH JoinSingles2All map=iter.maps/$BESTMAP data=- lodLimit=$LODLIMIT lodDifference=$LODDIFF iterate=1 numThreads=$PROCS > $DATAMAP
    cut -f 1 $DATAMAP | sort | uniq -c | sort -n
}

export -f joinsingles

ordermarkers(){
    printf "\nParentCall->SeparateChromosomes->JoinSingles->"
    printf "\033[01;33m" 
    printf " OrderMarkers\n" 
    printf "\033[0m"
    echo -e "\nThis step will order the markers on linkage groups 1:N"
    printf 'What distance-calculating method would you like to use (default, morgan, or kosambi)?  '
    read -r DISTTYPE
    case $DISTTYPE in
        kosambi)
            echo "using the Kosambi distance function"
            DISTMETHOD="useKosambi=1"
        ;;
        morgan)
            DISTMETHOD="useMorgan=1"
            echo "using Morgan linear distance"
        ;;
        *)
            echo "using the default LepMap3 distance calculation method"
            DISTMETHOD=""
    esac
    printf 'You want to order the markers on linkage groups 1 to... ?  '
    read -r NUMCHROM
    printf 'How many iterations per linkage group?  '
    read -r NUMITER
    printf 'This step runs in parallel. The number of chromosomes being run at once must be <= number CPUs '
    printf '\nHow many linkage groups would you like to order in parallel at once (max CPUs=%s)?  ' "$(nproc)"
    read -r NUMJOBS
    THREADS=$(echo $(nproc) $NUMCHROM 1.5 | awk '{ printf("%.0f\n", $1/($2/$3)) }')
    NUMLOCI=$(tail -n +2 ./$DATAMAP | wc -l)
    NUMINDS=$(( $(head -n 1 $PEDIGREE | awk '{print NF}') - 2 ))
    SCALEVAL=$(echo $NUMINDS $NUMLOCI | awk '{ print $1/$2 }')
    printf 'Data scaling will be set to %s based on %s markers and %s individuals\n' "$SCALEVAL" "$NUMLOCI" "$NUMINDS"
    echo -e "Depending on  the number of input CPUs iterations, this may take a WHILE. \nFeel free to detach the screen."
    mkdir -p ordermarkers/bestlikelihoods
    export DATAMAP
    export THREADS
    export DISTMETHOD
    export SCALEVAL
    export NUMITER
    runordermarkers() {
        for j in $(seq 1 $NUMITER)
            do
            zcat data_f.call.gz | java $LM3PATH OrderMarkers2 map=$DATAMAP data=- numThreads=$THREADS $DISTMETHOD scale=$SCALEVAL chromosome=$1 > ordermarkers/ordered.$1.$j.txt
        done
    }
    export -f runordermarkers
    seq 1 $NUMCHROM | parallel --jobs $NUMJOBS runordermarkers > ordermarkers.log

    # get likelihoods
    for i in $(seq 1 $NUMCHROM)
        do
        for j in $(seq 1 $NUMITER)
            do
            LG="ordered.$i"
            ITERUN="$j"
            LIKELIHOOD=$(head -2 ordermarkers/ordered.$i.$j.txt | tail -1 | cut -c 25-) 
            echo -e "$LG\t$ITERUN\t$LIKELIHOOD" >> ordermarkers/likelihoods.txt
        done
    done

    # sort by linkage group and likelihood
    sort ordermarkers/likelihoods.txt -k1,1 -k3,3nr > ordermarkers/likelihoods.sorted.txt

    # pull out best maps for each linkage group
    TOTALMAPS=$(cat ordermarkers/likelihoods.txt | wc -l)
    echo "Best ordered maps:"
    for i in $(seq 1 $NUMITER $TOTALMAPS); 
        do
        LIKELYMAP=$(sed -n ${i}p ordermarkers/likelihoods.sorted.txt | cut -f1,2 | awk '{print $0, $1 "." $NF}' | cut -d ' ' -f2)
        echo "$LIKELYMAP.txt"
        cp ordermarkers/$LIKELYMAP.txt ordermarkers/bestlikelihoods
    done
    printf "\nParentCall->SeparateChromosomes->JoinSingles->OrderMarkers->"
    printf "\033[01;33m" 
    printf " Trimming Ends\n" 
    printf "\033[0m"

    # run trimming script
    printf '\nAt what map distance cutoff would you like to trim end-clusters of markers? (10 is conservative)? '
    read -r TRIMTHRESH
    mkdir -p ./ordermarkers/best.trimmed
    Rscript /bin/LepMapp3rQA.r ./ordermarkers/bestlikelihoods ordered $TRIMTHRESH
    mv ./ordermarkers/bestlikelihoods/trimmed* bad.markers.txt ./ordermarkers/best.trimmed
    
    # reorder the trimmed markers
    mkdir -r -p ordermarkers.final/bestlikelihoods
    printf"\nParentCall->SeparateChromosomes->JoinSingles->OrderMarkers->Trimming Ends->"
    printf "\033[01;33m" 
    printf " Reordering\n" 
    printf "\033[0m"
    echo "This will take about as long as before. PAUSING"
    read PROCEED
    reordermarkers() {
        for j in $(seq 1 $NUMITER)
            do
            zcat data_f.call.gz | java $LM3PATH OrderMarkers2 map=$DATAMAP \
            data=- numThreads=$THREADS $DISTMETHOD \
            scale=$SCALEVAL \
            evaluateOrder=$1 > ordermarkers.final/reorder.$(basename $1).$j.txt
            ## NEED TO GET FILENAME EXAMPLE TO FINISH THE CUT COMMAND
            mv ordermarkers.final/reorder.$(basename $1).$j.txt ordermarkers.final/$(echo "reorder.$(basename $1).$j.txt" | cut -d'.' -f2)
        done
    }
    export -f reordermarkers
    
    find ./ordermarkers/best.trimmed -name "trimmed" | parallel reordermarkers > reordermarkers.log

    # get reordered linkage group likelihoods
    for i in $(seq 1 $NUMCHROM)
        do
        for j in $(seq 1 $NUMITER)
            do
            LG="reordered.$i"
            ITERUN="$j"
            LIKELIHOOD=$(head -2 ordermarkers.final/reorder.$i.$j.txt | tail -1 | cut -c 25-) 
            echo -e "$LG\t$ITERUN\t$LIKELIHOOD" >> ordermarkers.final/reordered.likelihoods.txt
        done
    done

    # sort by linkage group and likelihood
    sort ordermarkers.final/reordered.likelihoods.txt -k1,1 -k3,3nr > ordermarkers.final/reordered.likelihoods.sorted.txt

    # pull out best maps for each linkage group
    TOTALMAPS=$(cat ordermarkers.final/reordered.likelihoods.sorted.txt | wc -l)
    echo "Best reordered maps:"
    for i in $(seq 1 $NUMITER $TOTALMAPS); 
        do
        LIKELYMAP=$(sed -n ${i}p ordermarkers.final/reordered.likelihoods.sorted.txt | cut -f1,2 | awk '{print $0, $1 "." $NF}' | cut -d ' ' -f2)
        echo "$LIKELYMAP.txt"
        cp ordermarkers/$LIKELYMAP.txt ordermarkers.final/bestlikelihoods
    done

    ## calculate map distance and sex specific map distance
    mkdir -p final.distances
    for lgfile in ./ordermarkers.final/bestlikelihoods/order*.txt
    do
        zcat data_f.call.gz | java OrderMarkers2 data=- evaluateOrder=$lgfile  improveOrder=0 $DISTMETHOD > final.distances/$file.distance
        zcat data_f.call.gz | java OrderMarkers2 data=- evaluateOrder=$lgfile  improveOrder=0 sexAveraged=1 $DISTMETHOD > final.distances/$file.sexdistance
    done
}

export -f ordermarkers

# Run everything
if [ $# -eq 0 ]; then
    LM3PATH=$(echo "-cp /bin/LM3")
    export LM3PATH
    if [ ! -f "data_f.call.gz" ]; then
        parentcall && separatechromosomes && joinsingles && ordermarkers 
    else
        if [ ! -d "iter.maps" ]; then
            separatechromosomes && joinsingles && ordermarkers 
        elif test -n "$(find ./ -maxdepth 1 -name 'MASTER.map.LOD.*.txt' -print -quit)"; then
            echo -e "\n------------List of all files in working directory------------"
            ls .
            echo -e "----------------------------------------------------------------"
            printf '\nWhat is the name of the pedigree file? '
            read -r PEDIGREE
            if [ ! -f $PEDIGREE ]; then
                echo "Error: $PEDIGREE not found in working directory. Please check spelling." && exit 1
            fi
            printf 'Which map would you like to use for ordering (MASTER.map.LOD.*.txt)? '
            read -r BESTMAP
            if [ ! -f $BESTMAP ]; then
                echo "Error: $DATAMAP not found in working directory. Please check spelling." && exit 1
            else
            DATAMAP=$(echo "$BESTMAP")
            fi
            ordermarkers
        else
            joinsingles && ordermarkers
        fi
    fi
    exit 
elif [ $# -ne 0 ]; then
            cat <<EOF

LepMapp3r is a wrapper for LepMap3 (Rasta 2017) intended to link the modules together into a 
single workflow. To use it correctly, LepMap3 needs to be installed in /bin/LM3, however you 
can always modify LepMapp3r to point to where your installation is by editing Line 4. 
Additionally, you will need LepMapp3rQA.r installed in /bin as well, or wherever you want (so 
long as you change the location on line 138). To use LepMapp3r, simply run the command without
any arguments.

                             [LepMapp3r workflow]
ParentCall -> SeparateChromosomes -> JoinSingles -> OrderMarkers -> Trimming Ends-> Reordering

By default, if you run LepMapp3r without arguments it will start at ParentCall and work through
until the end. Ordering markers may take a while, so it is recommended to run LepMapp3r in a 
screen environment. LepMapp3r creates several folders during operation, and for safety, it is 
made to identify if these folders exist so as to skip that step and not overwrite data. 
Please remove or rename these folders as necessary to avoid unintentionally skipping steps: 
iter.maps
ordermarkers/best.trimmed 
ordermarkers/bestlikelihoods
ordermarkers.final/bestlikelihoods

                                [Disclaimer] 
LepMap3 is a very comprehensive software, and LepMapp3r cannot possibly incorporate all the
features and nuances within the various modules. Your study is unique, so you are encouraged 
to fork the GitHub repo and adapt LepMapp3r to your needs! 

                                 [Citation] 
Pasi Rastas, Lep-MAP3: robust linkage mapping even for low-coverage whole genome sequencing 
data, Bioinformatics, Volume 33, Issue 23, 01 December 2017, Pages 3726–3732, 
https://doi.org/10.1093/bioinformatics/btx494

EOF
fi
